\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9480}{}\doxysubsection{Creates a Promise that waits for a single event}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9480}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9481}{}\doxysection{Installation}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9481}
Install with {\ttfamily npm}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$ npm install @tootallnate/once}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9482}{}\doxysection{API}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9482}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9483}{}\doxysubsection{once(emitter\+: Event\+Emitter, name\+: string, opts?\+: Once\+Options)\+: Promise$<$\mbox{[}...\+Args\mbox{]}$>$}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9483}
Creates a Promise that waits for event {\ttfamily name} to occur on {\ttfamily emitter}, and resolves the promise with an array of the values provided to the event handler. If an {\ttfamily error} event occurs before the event specified by {\ttfamily name}, then the Promise is rejected with the error argument.


\begin{DoxyCode}{0}
\DoxyCodeLine{import once from '@tootallnate/once';}
\DoxyCodeLine{import \{ EventEmitter \} from 'events';}
\DoxyCodeLine{}
\DoxyCodeLine{const emitter = new EventEmitter();}
\DoxyCodeLine{}
\DoxyCodeLine{setTimeout(() => \{}
\DoxyCodeLine{    emitter.emit('foo', 'bar');}
\DoxyCodeLine{\}, 100);}
\DoxyCodeLine{}
\DoxyCodeLine{const [result] = await once(emitter, 'foo');}
\DoxyCodeLine{console.log(\{ result \});}
\DoxyCodeLine{// \{ result: 'bar' \}}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9484}{}\doxysubsubsection{Promise Strong Typing}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9484}
The main feature that this module provides over other \char`\"{}once\char`\"{} implementations is that the Promise that is returned is {\itshape {\bfseries{strongly typed}}} based on the type of {\ttfamily emitter} and the {\ttfamily name} of the event. Some examples are shown below.

{\itshape The process \char`\"{}exit\char`\"{} event contains a single number for exit code\+:}


\begin{DoxyCode}{0}
\DoxyCodeLine{const [code] = await once(process, 'exit');}
\DoxyCodeLine{//     \string^ number}

\end{DoxyCode}
 {\itshape A child process \char`\"{}exit\char`\"{} event contains either an exit code or a signal\+:}


\begin{DoxyCode}{0}
\DoxyCodeLine{const child = spawn('echo', []);}
\DoxyCodeLine{const [code, signal] = await once(child, 'exit');}
\DoxyCodeLine{//     \string^ number | null}
\DoxyCodeLine{//           \string^ string | null}

\end{DoxyCode}


{\itshape A forked child process \char`\"{}message\char`\"{} event is type {\ttfamily any}, so you can cast the Promise directly\+:}


\begin{DoxyCode}{0}
\DoxyCodeLine{const child = fork('file.js');}
\DoxyCodeLine{}
\DoxyCodeLine{// With `await`}
\DoxyCodeLine{const [message, \_]: [WorkerPayload, unknown] = await once(child, 'message');}
\DoxyCodeLine{}
\DoxyCodeLine{// With Promise}
\DoxyCodeLine{const messagePromise: Promise<[WorkerPayload, unknown]> = once(child, 'message');}
\DoxyCodeLine{}
\DoxyCodeLine{// Better yet would be to leave it as `any`, and validate the payload}
\DoxyCodeLine{// at runtime with i.e. `ajv` + `json-\/schema-\/to-\/typescript`}

\end{DoxyCode}


{\itshape If the Type\+Script definition does not contain an overload for the specified event name, then the Promise will have type {\ttfamily unknown\mbox{[}\mbox{]}} and your code will need to narrow the result manually\+:}


\begin{DoxyCode}{0}
\DoxyCodeLine{interface CustomEmitter extends EventEmitter \{}
\DoxyCodeLine{    on(name: 'foo', listener: (a: string, b: number) => void): this;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const emitter: CustomEmitter = new EventEmitter();}
\DoxyCodeLine{}
\DoxyCodeLine{// "{}foo"{} event is a defined overload, so it's properly typed}
\DoxyCodeLine{const fooPromise = once(emitter, 'foo');}
\DoxyCodeLine{//    \string^ Promise<[a: string, b: number]>}
\DoxyCodeLine{}
\DoxyCodeLine{// "{}bar"{} event in not a defined overload, so it gets `unknown[]`}
\DoxyCodeLine{const barPromise = once(emitter, 'bar');}
\DoxyCodeLine{//    \string^ Promise<unknown[]>}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9485}{}\doxysubsection{Once\+Options}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n9b8d154d99292f7db2c39ec895fe8359_autotoc_md9485}

\begin{DoxyItemize}
\item {\ttfamily signal} -\/ {\ttfamily Abort\+Signal} instance to unbind event handlers before the Promise has been fulfilled. 
\end{DoxyItemize}