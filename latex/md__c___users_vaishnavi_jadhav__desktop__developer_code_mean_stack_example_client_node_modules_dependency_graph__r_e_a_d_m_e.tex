Simple dependency graph\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dependency_graph__r_e_a_d_m_e_autotoc_md4441}{}\doxysection{Overview}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dependency_graph__r_e_a_d_m_e_autotoc_md4441}
This is a simple dependency graph useful for determining the order to do a list of things that depend on certain items being done before they are.

To use, {\ttfamily npm install dependency-\/graph} and then `require(\textquotesingle{}dependency-\/graph').Dep\+Graph\`{}\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dependency_graph__r_e_a_d_m_e_autotoc_md4442}{}\doxysection{API}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dependency_graph__r_e_a_d_m_e_autotoc_md4442}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dependency_graph__r_e_a_d_m_e_autotoc_md4443}{}\doxysubsection{Dep\+Graph}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dependency_graph__r_e_a_d_m_e_autotoc_md4443}
Nodes in the graph are just simple strings with optional data associated with them.


\begin{DoxyItemize}
\item {\ttfamily add\+Node(name, data)} -\/ add a node in the graph with optional data. If {\ttfamily data} is not given, {\ttfamily name} will be used as data
\item {\ttfamily remove\+Node(name)} -\/ remove a node from the graph
\item {\ttfamily has\+Node(name)} -\/ check if a node exists in the graph
\item {\ttfamily size()} -\/ return the number of nodes in the graph
\item {\ttfamily get\+Node\+Data(name)} -\/ get the data associated with a node (will throw an {\ttfamily Error} if the node does not exist)
\item {\ttfamily set\+Node\+Data(name, data)} -\/ set the data for an existing node (will throw an {\ttfamily Error} if the node does not exist)
\item {\ttfamily add\+Dependency(from, to)} -\/ add a dependency between two nodes (will throw an {\ttfamily Error} if one of the nodes does not exist)
\item {\ttfamily remove\+Dependency(from, to)} -\/ remove a dependency between two nodes
\item {\ttfamily clone()} -\/ return a clone of the graph. Any data attached to the nodes will only be {\itshape shallow-\/copied}
\item {\ttfamily dependencies\+Of(name, leaves\+Only)} -\/ get an array containing the nodes that the specified node depends on (transitively). If {\ttfamily leaves\+Only} is true, only nodes that do not depend on any other nodes will be returned in the array.
\item {\ttfamily dependants\+Of(name, leaves\+Only)} (aliased as {\ttfamily dependents\+Of}) -\/ get an array containing the nodes that depend on the specified node (transitively). If {\ttfamily leaves\+Only} is true, only nodes that do not have any dependants will be returned in the array.
\item {\ttfamily direct\+Dependencies\+Of(name)} -\/ get an array containing the direct dependencies of the specified node
\item {\ttfamily direct\+Dependants\+Of(name)} (aliased as {\ttfamily direct\+Dependents\+Of}) -\/ get an array containing the nodes that directly depend on the specified node
\item {\ttfamily overall\+Order(leaves\+Only)} -\/ construct the overall processing order for the dependency graph. If {\ttfamily leaves\+Only} is true, only nodes that do not depend on any other nodes will be returned.
\item {\ttfamily entry\+Nodes()} -\/ array of nodes that have no dependants (i.\+e. nothing depends on them).
\end{DoxyItemize}

Dependency Cycles are detected when running {\ttfamily dependencies\+Of}, {\ttfamily dependants\+Of}, and {\ttfamily overall\+Order} and if one is found, a {\ttfamily Dep\+Graph\+Cycle\+Error} will be thrown that includes what the cycle was in the message as well as the {\ttfamily cycle\+Path} property\+: e.\+g. {\ttfamily Dependency Cycle Found\+: a -\/\texorpdfstring{$>$}{>} b -\/\texorpdfstring{$>$}{>} c -\/\texorpdfstring{$>$}{>} a}. If you wish to silence this error, pass {\ttfamily circular\+: true} when instantiating {\ttfamily Dep\+Graph} (more below).\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dependency_graph__r_e_a_d_m_e_autotoc_md4444}{}\doxysection{Examples}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dependency_graph__r_e_a_d_m_e_autotoc_md4444}
\begin{DoxyVerb}var DepGraph = require('dependency-graph').DepGraph;

var graph = new DepGraph();
graph.addNode('a');
graph.addNode('b');
graph.addNode('c');

graph.size() // 3

graph.addDependency('a', 'b');
graph.addDependency('b', 'c');

graph.dependenciesOf('a'); // ['c', 'b']
graph.dependenciesOf('b'); // ['c']
graph.dependantsOf('c'); // ['a', 'b']

graph.overallOrder(); // ['c', 'b', 'a']
graph.overallOrder(true); // ['c']
graph.entryNodes(); // ['a']

graph.addNode('d', 'data');

graph.getNodeData('d'); // 'data'

graph.setNodeData('d', 'newData');

graph.getNodeData('d'); // 'newData'

var circularGraph = new DepGraph({ circular: true });

circularGraph.addNode('a');
circularGraph.addNode('b');
circularGraph.addNode('c');
circularGraph.addNode('d');

circularGraph.addDependency('a', 'b');
circularGraph.addDependency('b', 'c'); // b depends on c
circularGraph.addDependency('c', 'a'); // c depends on a, which depends on b
circularGraph.addDependency('d', 'a');

circularGraph.dependenciesOf('b'); // ['a', 'c']
circularGraph.overallOrder(); // ['c', 'b', 'a', 'd']
\end{DoxyVerb}
 