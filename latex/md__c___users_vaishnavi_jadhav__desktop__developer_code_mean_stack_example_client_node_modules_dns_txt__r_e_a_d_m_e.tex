Encode or decode the RDATA field in multicast DNS TXT records. For use with DNS-\/\+Based Service Discovery. For details see \href{https://tools.ietf.org/html/rfc6763}{\texttt{ RFC 6763}}.

\href{https://travis-ci.org/watson/dns-txt}{\texttt{ }} \href{https://github.com/feross/standard}{\texttt{ }} \href{https://github.com/mafintosh/abstract-encoding}{\texttt{ }}\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4487}{}\doxysection{Installation}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4487}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm install dns-\/txt}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4488}{}\doxysection{Usage}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4488}

\begin{DoxyCode}{0}
\DoxyCodeLine{var txt = require('dns-\/txt')()}
\DoxyCodeLine{}
\DoxyCodeLine{var obj = \{}
\DoxyCodeLine{  foo: 1,}
\DoxyCodeLine{  bar: 2}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{var enc = txt.encode(obj) // <Buffer 05 66 6f 6f 3d 31 05 62 61 72 3d 32>}
\DoxyCodeLine{}
\DoxyCodeLine{txt.decode(enc) // \{ foo: '1', bar: '2' \}}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4489}{}\doxysection{API}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4489}
The encoder and decoder conforms to \href{https://tools.ietf.org/html/rfc6763}{\texttt{ RFC 6763}}.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4490}{}\doxysubsection{Initialize}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4490}
The module exposes a constructor function which can be called with an optional options object\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var txt = require('dns-\/txt')(\{ binary: true \})}

\end{DoxyCode}


The options are\+:


\begin{DoxyItemize}
\item {\ttfamily binary} -\/ If set to {\ttfamily true} all values will be returned as {\ttfamily Buffer} objects. The default behavior is to turn all values into strings. But according to the RFC the values can be any binary data. If you expect binary data, use this option.
\end{DoxyItemize}\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4491}{}\doxysubsubsection{$<$tt$>$txt.\+encode(obj, \mbox{[}buffer\mbox{]}, \mbox{[}offset\mbox{]})$<$/tt$>$}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4491}
Takes a key/value object and returns a buffer with the encoded TXT record. If a buffer is passed as the second argument the object should be encoded into that buffer. Otherwise a new buffer should be allocated If an offset is passed as the third argument the object should be encoded at that byte offset. The byte offset defaults to {\ttfamily 0}.

This module does not actively validate the key/value pairs, but keep the following in rules in mind\+:


\begin{DoxyItemize}
\item To be RFC compliant, each key should conform with the rules as specified in \href{https://tools.ietf.org/html/rfc6763\#section-6.4}{\texttt{ section 6.\+4}}.
\item To be RFC compliant, each value should conform with the rules as specified in \href{https://tools.ietf.org/html/rfc6763\#section-6.5}{\texttt{ section 6.\+5}}.
\end{DoxyItemize}

After encoding {\ttfamily txt.\+encode.\+bytes} is set to the amount of bytes used to encode the object.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4492}{}\doxysubsubsection{$<$tt$>$txt.\+decode(buffer, \mbox{[}offset\mbox{]}, \mbox{[}length\mbox{]})$<$/tt$>$}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4492}
Takes a buffer and returns a decoded key/value object. If an offset is passed as the second argument the object should be decoded from that byte offset. The byte offset defaults to {\ttfamily 0}. Note that all keys will be lowercased and all values will be Buffer objects.

After decoding {\ttfamily txt.\+decode.\+bytes} is set to the amount of bytes used to decode the object.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4493}{}\doxysubsubsection{$<$tt$>$txt.\+encoding\+Length(obj)$<$/tt$>$}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4493}
Takes a single key/value object and returns the number of bytes that the given object would require if encoded.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4494}{}\doxysection{License}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_dns_txt__r_e_a_d_m_e_autotoc_md4494}
MIT 