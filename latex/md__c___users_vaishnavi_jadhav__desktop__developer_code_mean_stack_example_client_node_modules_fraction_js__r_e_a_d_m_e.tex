\href{https://npmjs.org/package/fraction.js}{\texttt{ }}

\href{https://travis-ci.org/infusion/Fraction.js}{\texttt{ }} \href{http://opensource.org/licenses/MIT}{\texttt{ }}

Tired of inprecise numbers represented by doubles, which have to store rational and irrational numbers like PI or sqrt(2) the same way? Obviously the following problem is preventable\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{1 / 98 * 98 // = 0.9999999999999999}

\end{DoxyCode}


If you need more precision or just want a fraction as a result, have a look at {\itshape Fraction.\+js}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var Fraction = require('fraction.js');}
\DoxyCodeLine{}
\DoxyCodeLine{Fraction(1).div(98).mul(98) // = 1}

\end{DoxyCode}


Internally, numbers are represented as {\itshape numerator / denominator}, which adds just a little overhead. However, the library is written with performance in mind and outperforms any other implementation, as you can see \href{http://jsperf.com/convert-a-rational-number-to-a-babylonian-fractions/28}{\texttt{ here}}. This basic data-\/type makes it the perfect basis for \href{https://github.com/infusion/Polynomial.js}{\texttt{ Polynomial.\+js}} and \href{https://github.com/josdejong/mathjs}{\texttt{ Math.\+js}}.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5648}{}\doxysection{Convert decimal to fraction}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5648}
The simplest job for fraction.\+js is to get a fraction out of a decimal\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var x = new Fraction(1.88);}
\DoxyCodeLine{var res = x.toFraction(true); // String "{}1 22/25"{}}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5649}{}\doxysection{Examples / Motivation}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5649}
A simple example might be


\begin{DoxyCode}{0}
\DoxyCodeLine{var f = new Fraction("{}9.4'31'"{}); // 9.4313131313131...}
\DoxyCodeLine{f.mul([-\/4, 3]).mod("{}4.'8'"{}); // 4.88888888888888...}

\end{DoxyCode}
 The result is


\begin{DoxyCode}{0}
\DoxyCodeLine{console.log(f.toFraction()); // -\/4154 / 1485}

\end{DoxyCode}
 You could of course also access the sign (s), numerator (n) and denominator (d) on your own\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{f.s * f.n / f.d = -\/1 * 4154 / 1485 = -\/2.797306...}

\end{DoxyCode}


If you would try to calculate it yourself, you would come up with something like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{(9.4313131 * (-\/4 / 3)) \% 4.888888 = -\/2.797308133...}

\end{DoxyCode}


Quite okay, but yea -\/ not as accurate as it could be.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5650}{}\doxysection{Laplace Probability}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5650}
Simple example. What\textquotesingle{}s the probability of throwing a 3, and 1 or 4, and 2 or 4 or 6 with a fair dice?

P(\{3\})\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var p = new Fraction([3].length, 6).toString(); // 0.1(6)}

\end{DoxyCode}


P(\{1, 4\})\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var p = new Fraction([1, 4].length, 6).toString(); // 0.(3)}

\end{DoxyCode}


P(\{2, 4, 6\})\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{var p = new Fraction([2, 4, 6].length, 6).toString(); // 0.5}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5651}{}\doxysection{Convert degrees/minutes/seconds to precise rational representation\+:}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5651}
57+45/60+17/3600 
\begin{DoxyCode}{0}
\DoxyCodeLine{var deg = 57; // 57°}
\DoxyCodeLine{var min = 45; // 45 Minutes}
\DoxyCodeLine{var sec = 17; // 17 Seconds}
\DoxyCodeLine{}
\DoxyCodeLine{new Fraction(deg).add(min, 60).add(sec, 3600).toString() // -\/> 57.7547(2)}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5652}{}\doxysection{Rounding a fraction to the closest tape measure value}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5652}
A tape measure is usually divided in parts of {\ttfamily 1/16}. Rounding a given fraction to the closest value on a tape measure can be determined by


\begin{DoxyCode}{0}
\DoxyCodeLine{function closestTapeMeasure(frac) \{}
\DoxyCodeLine{}
\DoxyCodeLine{    /*}
\DoxyCodeLine{    k/16 ≤ a/b < (k+1)/16}
\DoxyCodeLine{    ⇔ k ≤ 16*a/b < (k+1)}
\DoxyCodeLine{    ⇔ k = floor(16*a/b)}
\DoxyCodeLine{    */}
\DoxyCodeLine{    return new Fraction(Math.round(16 * Fraction(frac).valueOf()), 16);}
\DoxyCodeLine{\}}
\DoxyCodeLine{// closestTapeMeasure("{}1/3"{}) // 5/16}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5653}{}\doxysection{Rational approximation of irrational numbers}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5653}
Now it\textquotesingle{}s getting messy ;d To approximate a number like {\itshape sqrt(5) -\/ 2} with a numerator and denominator, you can reformat the equation as follows\+: {\itshape pow(n / d + 2, 2) = 5}.

Then the following algorithm will generate the rational number besides the binary representation.


\begin{DoxyCode}{0}
\DoxyCodeLine{var x = "{}/"{}, s = "{}"{};}
\DoxyCodeLine{}
\DoxyCodeLine{var a = new Fraction(0),}
\DoxyCodeLine{    b = new Fraction(1);}
\DoxyCodeLine{for (var n = 0; n <= 10; n++) \{}
\DoxyCodeLine{}
\DoxyCodeLine{  var c = a.add(b).div(2);}
\DoxyCodeLine{}
\DoxyCodeLine{  console.log(n + "{}\(\backslash\)t"{} + a + "{}\(\backslash\)t"{} + b + "{}\(\backslash\)t"{} + c + "{}\(\backslash\)t"{} + x);}
\DoxyCodeLine{}
\DoxyCodeLine{  if (c.add(2).pow(2) < 5) \{}
\DoxyCodeLine{    a = c;}
\DoxyCodeLine{    x = "{}1"{};}
\DoxyCodeLine{  \} else \{}
\DoxyCodeLine{    b = c;}
\DoxyCodeLine{    x = "{}0"{};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  s+= x;}
\DoxyCodeLine{\}}
\DoxyCodeLine{console.log(s)}

\end{DoxyCode}


The result is


\begin{DoxyCode}{0}
\DoxyCodeLine{n   a[n]        b[n]        c[n]            x[n]}
\DoxyCodeLine{0   0/1         1/1         1/2             /}
\DoxyCodeLine{1   0/1         1/2         1/4             0}
\DoxyCodeLine{2   0/1         1/4         1/8             0}
\DoxyCodeLine{3   1/8         1/4         3/16            1}
\DoxyCodeLine{4   3/16        1/4         7/32            1}
\DoxyCodeLine{5   7/32        1/4         15/64           1}
\DoxyCodeLine{6   15/64       1/4         31/128          1}
\DoxyCodeLine{7   15/64       31/128      61/256          0}
\DoxyCodeLine{8   15/64       61/256      121/512         0}
\DoxyCodeLine{9   15/64       121/512     241/1024        0}
\DoxyCodeLine{10  241/1024    121/512     483/2048        1}

\end{DoxyCode}
 Thus the approximation after 11 iterations of the bisection method is {\itshape 483 / 2048} and the binary representation is 0.\+00111100011 (see \href{http://www.wolframalpha.com/input/?i=sqrt\%285\%29-2+binary}{\texttt{ Wolfram\+Alpha}})

I published another example on how to approximate PI with fraction.\+js on my \href{http://www.xarg.org/2014/03/precise-calculations-in-javascript/}{\texttt{ blog}} (Still not the best idea to approximate irrational numbers, but it illustrates the capabilities of Fraction.\+js perfectly).\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5654}{}\doxysubsection{Get the exact fractional part of a number}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5654}

\begin{DoxyCode}{0}
\DoxyCodeLine{var f = new Fraction("{}-\/6.(3416)"{});}
\DoxyCodeLine{console.log("{}"{} + f.mod(1).abs()); // Will print 0.(3416)}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5655}{}\doxysubsection{Mathematical correct modulo}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5655}
The behaviour on negative congruences is different to most modulo implementations in computer science. Even the {\itshape mod()} function of Fraction.\+js behaves in the typical way. To solve the problem of having the mathematical correct modulo with Fraction.\+js you could come up with this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var a = -\/1;}
\DoxyCodeLine{var b = 10.99;}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(new Fraction(a)}
\DoxyCodeLine{  .mod(b)); // Not correct, usual Modulo}
\DoxyCodeLine{}
\DoxyCodeLine{console.log(new Fraction(a)}
\DoxyCodeLine{  .mod(b).add(b).mod(b)); // Correct! Mathematical Modulo}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5656}{}\doxysubsection{fmod() impreciseness circumvented}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5656}
It turns out that Fraction.\+js outperforms almost any fmod() implementation, including Java\+Script itself, \href{http://phpjs.org/functions/fmod/}{\texttt{ php.\+js}}, C++, Python, Java and even Wolframalpha due to the fact that numbers like 0.\+05, 0.\+1, ... are infinite decimal in base 2.

The equation {\itshape fmod(4.\+55, 0.\+05)} gives {\itshape 0.\+04999999999999957}, wolframalpha says {\itshape 1/20}. The correct answer should be {\bfseries{zero}}, as 0.\+05 divides 4.\+55 without any remainder.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5657}{}\doxysection{Parser}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5657}
Any function (see below) as well as the constructor of the {\itshape Fraction} class parses its input and reduce it to the smallest term.

You can pass either Arrays, Objects, Integers, Doubles or Strings.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5658}{}\doxysubsection{Arrays / Objects}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5658}

\begin{DoxyCode}{0}
\DoxyCodeLine{new Fraction(numerator, denominator);}
\DoxyCodeLine{new Fraction([numerator, denominator]);}
\DoxyCodeLine{new Fraction(\{n: numerator, d: denominator\});}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5659}{}\doxysubsection{Integers}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5659}

\begin{DoxyCode}{0}
\DoxyCodeLine{new Fraction(123);}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5660}{}\doxysubsection{Doubles}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5660}

\begin{DoxyCode}{0}
\DoxyCodeLine{new Fraction(55.4);}

\end{DoxyCode}


{\bfseries{Note\+:}} If you pass a double as it is, Fraction.\+js will perform a number analysis based on Farey Sequences. If you concern performance, cache Fraction.\+js objects and pass arrays/objects.

The method is really precise, but too large exact numbers, like 1234567.\+9991829 will result in a wrong approximation. If you want to keep the number as it is, convert it to a string, as the string parser will not perform any further observations. If you have problems with the approximation, in the file {\ttfamily examples/approx.\+js} is a different approximation algorithm, which might work better in some more specific use-\/cases.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5661}{}\doxysubsection{Strings}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5661}

\begin{DoxyCode}{0}
\DoxyCodeLine{new Fraction("{}123.45"{});}
\DoxyCodeLine{new Fraction("{}123/45"{}); // A rational number represented as two decimals, separated by a slash}
\DoxyCodeLine{new Fraction("{}123:45"{}); // A rational number represented as two decimals, separated by a colon}
\DoxyCodeLine{new Fraction("{}4 123/45"{}); // A rational number represented as a whole number and a fraction}
\DoxyCodeLine{new Fraction("{}123.'456'"{}); // Note the quotes, see below!}
\DoxyCodeLine{new Fraction("{}123.(456)"{}); // Note the brackets, see below!}
\DoxyCodeLine{new Fraction("{}123.45'6'"{}); // Note the quotes, see below!}
\DoxyCodeLine{new Fraction("{}123.45(6)"{}); // Note the brackets, see below!}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5662}{}\doxysubsection{Two arguments}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5662}

\begin{DoxyCode}{0}
\DoxyCodeLine{new Fraction(3, 2); // 3/2 = 1.5}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5663}{}\doxysubsection{Repeating decimal places}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5663}
{\itshape Fraction.\+js} can easily handle repeating decimal places. For example {\itshape 1/3} is {\itshape 0.\+3333...}. There is only one repeating digit. As you can see in the examples above, you can pass a number like {\itshape 1/3} as \char`\"{}0.\textquotesingle{}3\textquotesingle{}\char`\"{} or \char`\"{}0.(3)\char`\"{}, which are synonym. There are no tests to parse something like 0.\+166666666 to 1/6! If you really want to handle this number, wrap around brackets on your own with the function below for example\+: 0.\+1(66666666)

Assume you want to divide 123.\+32 / 33.\+6(567). \href{http://www.wolframalpha.com/input/?i=123.32+\%2F+\%2812453\%2F370\%29}{\texttt{ Wolfram\+Alpha}} states that you\textquotesingle{}ll get a period of 1776 digits. {\itshape Fraction.\+js} comes to the same result. Give it a try\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var f = new Fraction("{}123.32"{});}
\DoxyCodeLine{console.log("{}Bam: "{} + f.div("{}33.6(567)"{}));}

\end{DoxyCode}


To automatically make a number like \char`\"{}0.\+123123123\char`\"{} to something more Fraction.\+js friendly like \char`\"{}0.(123)\char`\"{}, I hacked this little brute force algorithm in a 10 minutes. Improvements are welcome...


\begin{DoxyCode}{0}
\DoxyCodeLine{function formatDecimal(str) \{}
\DoxyCodeLine{}
\DoxyCodeLine{  var comma, pre, offset, pad, times, repeat;}
\DoxyCodeLine{}
\DoxyCodeLine{  if (-\/1 === (comma = str.indexOf("{}."{})))}
\DoxyCodeLine{    return str;}
\DoxyCodeLine{}
\DoxyCodeLine{  pre = str.substr(0, comma + 1);}
\DoxyCodeLine{  str = str.substr(comma + 1);}
\DoxyCodeLine{}
\DoxyCodeLine{  for (var i = 0; i < str.length; i++) \{}
\DoxyCodeLine{}
\DoxyCodeLine{    offset = str.substr(0, i);}
\DoxyCodeLine{}
\DoxyCodeLine{    for (var j = 0; j < 5; j++) \{}
\DoxyCodeLine{}
\DoxyCodeLine{      pad = str.substr(i, j + 1);}
\DoxyCodeLine{}
\DoxyCodeLine{      times = Math.ceil((str.length -\/ offset.length) / pad.length);}
\DoxyCodeLine{}
\DoxyCodeLine{      repeat = new Array(times + 1).join(pad); // Silly String.repeat hack}
\DoxyCodeLine{}
\DoxyCodeLine{      if (0 === (offset + repeat).indexOf(str)) \{}
\DoxyCodeLine{        return pre + offset + "{}("{} + pad + "{})"{};}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  return null;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{var f, x = formatDecimal("{}13.0123123123"{}); // = 13.0(123)}
\DoxyCodeLine{if (x !== null) \{}
\DoxyCodeLine{  f = new Fraction(x);}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5664}{}\doxysection{Attributes}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5664}
The Fraction object allows direct access to the numerator, denominator and sign attributes. It is ensured that only the sign-\/attribute holds sign information so that a sign comparison is only necessary against this attribute.


\begin{DoxyCode}{0}
\DoxyCodeLine{var f = new Fraction('-\/1/2');}
\DoxyCodeLine{console.log(f.n); // Numerator: 1}
\DoxyCodeLine{console.log(f.d); // Denominator: 2}
\DoxyCodeLine{console.log(f.s); // Sign: -\/1}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5665}{}\doxysection{Functions}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5665}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5666}{}\doxysubsection{Fraction abs()}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5666}
Returns the actual number without any sign information\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5667}{}\doxysubsection{Fraction neg()}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5667}
Returns the actual number with flipped sign in order to get the additive inverse\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5668}{}\doxysubsection{Fraction add(n)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5668}
Returns the sum of the actual number and the parameter n\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5669}{}\doxysubsection{Fraction sub(n)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5669}
Returns the difference of the actual number and the parameter n\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5670}{}\doxysubsection{Fraction mul(n)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5670}
Returns the product of the actual number and the parameter n\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5671}{}\doxysubsection{Fraction div(n)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5671}
Returns the quotient of the actual number and the parameter n\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5672}{}\doxysubsection{Fraction pow(exp)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5672}
Returns the power of the actual number, raised to an possible rational exponent. If the result becomes non-\/rational the function returns {\ttfamily null}.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5673}{}\doxysubsection{Fraction mod(n)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5673}
Returns the modulus (rest of the division) of the actual object and n (this \% n). It\textquotesingle{}s a much more precise fmod() if you will. Please note that {\itshape mod()} is just like the modulo operator of most programming languages. If you want a mathematical correct modulo, see here.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5674}{}\doxysubsection{Fraction mod()}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5674}
Returns the modulus (rest of the division) of the actual object (numerator mod denominator)\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5675}{}\doxysubsection{Fraction gcd(n)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5675}
Returns the fractional greatest common divisor\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5676}{}\doxysubsection{Fraction lcm(n)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5676}
Returns the fractional least common multiple\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5677}{}\doxysubsection{Fraction ceil(\mbox{[}places=0-\/16\mbox{]})}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5677}
Returns the ceiling of a rational number with Math.\+ceil\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5678}{}\doxysubsection{Fraction floor(\mbox{[}places=0-\/16\mbox{]})}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5678}
Returns the floor of a rational number with Math.\+floor\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5679}{}\doxysubsection{Fraction round(\mbox{[}places=0-\/16\mbox{]})}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5679}
Returns the rational number rounded with Math.\+round\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5680}{}\doxysubsection{Fraction inverse()}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5680}
Returns the multiplicative inverse of the actual number (n / d becomes d / n) in order to get the reciprocal\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5681}{}\doxysubsection{Fraction simplify(\mbox{[}eps=0.\+001\mbox{]})}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5681}
Simplifies the rational number under a certain error threshold. Ex. {\ttfamily 0.\+333} will be {\ttfamily 1/3} with {\ttfamily eps=0.\+001}\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5682}{}\doxysubsection{boolean equals(n)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5682}
Check if two numbers are equal\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5683}{}\doxysubsection{int compare(n)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5683}
Compare two numbers. 
\begin{DoxyCode}{0}
\DoxyCodeLine{result < 0: n is greater than actual number}
\DoxyCodeLine{result > 0: n is smaller than actual number}
\DoxyCodeLine{result = 0: n is equal to the actual number}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5684}{}\doxysubsection{boolean divisible(n)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5684}
Check if two numbers are divisible (n divides this)\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5685}{}\doxysubsection{double value\+Of()}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5685}
Returns a decimal representation of the fraction\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5686}{}\doxysubsection{String to\+String(\mbox{[}decimal\+Places=15\mbox{]})}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5686}
Generates an exact string representation of the actual object. For repeated decimal places all digits are collected within brackets, like {\ttfamily 1/3 = \char`\"{}0.(3)\char`\"{}}. For all other numbers, up to {\ttfamily decimal\+Places} significant digits are collected -\/ which includes trailing zeros if the number is getting truncated. However, {\ttfamily 1/2 = \char`\"{}0.\+5\char`\"{}} without trailing zeros of course.

{\bfseries{Note\+:}} As {\ttfamily value\+Of()} and {\ttfamily to\+String()} are provided, {\ttfamily to\+String()} is only called implicitly in a real string context. Using the plus-\/operator like {\ttfamily \char`\"{}123\char`\"{} + new Fraction} will call value\+Of(), because Java\+Script tries to combine two primitives first and concatenates them later, as string will be the more dominant type. {\ttfamily alert(new Fraction)} or {\ttfamily String(new Fraction)} on the other hand will do what you expect. If you really want to have control, you should call {\ttfamily to\+String()} or {\ttfamily value\+Of()} explicitly!\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5687}{}\doxysubsection{String to\+Latex(exclude\+Whole=false)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5687}
Generates an exact La\+TeX representation of the actual object. You can see a \href{http://www.xarg.org/2014/03/precise-calculations-in-javascript/}{\texttt{ live demo}} on my blog.

The optional boolean parameter indicates if you want to exclude the whole part. \char`\"{}1 1/3\char`\"{} instead of \char`\"{}4/3\char`\"{}\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5688}{}\doxysubsection{String to\+Fraction(exclude\+Whole=false)}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5688}
Gets a string representation of the fraction

The optional boolean parameter indicates if you want to exclude the whole part. \char`\"{}1 1/3\char`\"{} instead of \char`\"{}4/3\char`\"{}\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5689}{}\doxysubsection{Array to\+Continued()}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5689}
Gets an array of the fraction represented as a continued fraction. The first element always contains the whole part.


\begin{DoxyCode}{0}
\DoxyCodeLine{var f = new Fraction('88/33');}
\DoxyCodeLine{var c = f.toContinued(); // [2, 1, 2]}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5690}{}\doxysubsection{Fraction clone()}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5690}
Creates a copy of the actual Fraction object\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5691}{}\doxysection{Exceptions}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5691}
If a really hard error occurs (parsing error, division by zero), {\itshape fraction.\+js} throws exceptions! Please make sure you handle them correctly.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5692}{}\doxysection{Installation}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5692}
Installing fraction.\+js is as easy as cloning this repo or use one of the following commands\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{bower install fraction.js}

\end{DoxyCode}
 or


\begin{DoxyCode}{0}
\DoxyCodeLine{npm install fraction.js}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5693}{}\doxysection{Using Fraction.\+js with the browser}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5693}

\begin{DoxyCode}{0}
\DoxyCodeLine{<script src="{}fraction.js"{}></script>}
\DoxyCodeLine{<script>}
\DoxyCodeLine{    console.log(Fraction("{}123/456"{}));}
\DoxyCodeLine{</script>}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5694}{}\doxysection{Using Fraction.\+js with require.\+js}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5694}

\begin{DoxyCode}{0}
\DoxyCodeLine{<script src="{}require.js"{}></script>}
\DoxyCodeLine{<script>}
\DoxyCodeLine{requirejs(['fraction.js'],}
\DoxyCodeLine{function(Fraction) \{}
\DoxyCodeLine{    console.log(Fraction("{}123/456"{}));}
\DoxyCodeLine{\});}
\DoxyCodeLine{</script>}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5695}{}\doxysection{Using Fraction.\+js with Type\+Script}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5695}

\begin{DoxyCode}{0}
\DoxyCodeLine{import Fraction from "{}fraction.js"{};}
\DoxyCodeLine{console.log(Fraction("{}123/456"{}));}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5696}{}\doxysection{Coding Style}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5696}
As every library I publish, fraction.\+js is also built to be as small as possible after compressing it with Google Closure Compiler in advanced mode. Thus the coding style orientates a little on maxing-\/out the compression rate. Please make sure you keep this style if you plan to extend the library.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5697}{}\doxysection{Precision}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5697}
Fraction.\+js tries to circumvent floating point errors, by having an internal representation of numerator and denominator. As it relies on Java\+Script, there is also a limit. The biggest number representable is {\ttfamily Number.\+MAX\+\_\+\+SAFE\+\_\+\+INTEGER / 1} and the smallest is {\ttfamily -\/1 / Number.\+MAX\+\_\+\+SAFE\+\_\+\+INTEGER}, with {\ttfamily Number.\+MAX\+\_\+\+SAFE\+\_\+\+INTEGER=9007199254740991}. If this is not enough, there is {\ttfamily bigfraction.\+js} shipped experimentally, which relies on {\ttfamily Big\+Int} and should become the new Fraction.\+js eventually.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5698}{}\doxysection{Testing}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5698}
If you plan to enhance the library, make sure you add test cases and all the previous tests are passing. You can test the library with


\begin{DoxyCode}{0}
\DoxyCodeLine{npm test}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5699}{}\doxysection{Copyright and licensing}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_fraction_js__r_e_a_d_m_e_autotoc_md5699}
Copyright (c) 2014-\/2019, \href{https://www.xarg.org/}{\texttt{ Robert Eisele}} Dual licensed under the MIT or GPL Version 2 licenses. 