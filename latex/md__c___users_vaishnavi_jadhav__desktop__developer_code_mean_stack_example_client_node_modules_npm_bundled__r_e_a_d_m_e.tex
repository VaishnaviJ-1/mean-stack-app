Run this in a node package, and it\textquotesingle{}ll tell you which things in node\+\_\+modules are bundled\+Dependencies, or transitive dependencies of bundled dependencies.

\href{https://travis-ci.org/npm/npm-bundled}{\texttt{ }}\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_npm_bundled__r_e_a_d_m_e_autotoc_md9405}{}\doxysection{USAGE}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_npm_bundled__r_e_a_d_m_e_autotoc_md9405}
To get the list of deps at the top level that are bundled (or transitive deps of a bundled dep) run this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const bundled = require('npm-\/bundled')}
\DoxyCodeLine{}
\DoxyCodeLine{// async version}
\DoxyCodeLine{bundled(\{ path: '/path/to/pkg/defaults/to/cwd'\}, (er, list) => \{}
\DoxyCodeLine{  // er means it had an error, which is \_hella\_ weird}
\DoxyCodeLine{  // list is a list of package names, like `fooblz` or `@corp/blerg`}
\DoxyCodeLine{  // the might not all be deps of the top level, because transitives}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{// async promise version}
\DoxyCodeLine{bundled(\{ path: '/path/to/pkg/defaults/to/cwd'\}).then(list => \{}
\DoxyCodeLine{  // so promisey!}
\DoxyCodeLine{  // actually the callback version returns a promise, too, it just}
\DoxyCodeLine{  // attaches the supplied callback to the promise}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{// sync version, throws if there's an error}
\DoxyCodeLine{const list = bundled(\{ path: '/path/to/pkg/defaults/to/cwd'\})}

\end{DoxyCode}


That\textquotesingle{}s basically all you need to know. If you care to dig into it, you can also use the {\ttfamily bundled.\+Walker} and {\ttfamily bundled.\+Walker\+Sync} classes to get fancy.

This library does not write anything to the filesystem, but it {\itshape may} have undefined behavior if the structure of {\ttfamily node\+\_\+modules} changes while it\textquotesingle{}s reading deps.

All symlinks are followed. This means that it can lead to surprising results if a symlinked bundled dependency has a missing dependency that is satisfied at the top level. Since package creation resolves symlinks as well, this is an edge case where package creation and development environment are not going to be aligned, and is best avoided. 