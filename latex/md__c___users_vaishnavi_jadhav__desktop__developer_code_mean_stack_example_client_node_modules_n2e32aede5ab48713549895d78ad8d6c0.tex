A cache object that deletes the least-\/recently-\/used items.

Specify a max number of the most recently used items that you want to keep, and this cache will keep that many of the most recently accessed items.

This is not primarily a TTL cache, and does not make strong TTL guarantees. There is no preemptive pruning of expired items, but you {\itshape may} set a TTL on the cache or on a single {\ttfamily set}. If you do so, it will treat expired items as missing, and delete them when fetched.

As of version 7, this is one of the most performant LRU implementations available in Java\+Script, and supports a wide diversity of use cases. However, note that using some of the features will necessarily impact performance, by causing the cache to have to do more work. See the \char`\"{}\+Performance\char`\"{} section below.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9491}{}\doxysection{Installation}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9491}

\begin{DoxyCode}{0}
\DoxyCodeLine{npm install lru-\/cache -\/-\/save}

\end{DoxyCode}
\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9492}{}\doxysection{Usage}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9492}

\begin{DoxyCode}{0}
\DoxyCodeLine{const LRU = require('lru-\/cache')}
\DoxyCodeLine{}
\DoxyCodeLine{// only 'max' is required, the others are optional, but MAY be}
\DoxyCodeLine{// required if certain other fields are set.}
\DoxyCodeLine{const options = \{}
\DoxyCodeLine{  // the number of most recently used items to keep.}
\DoxyCodeLine{  // note that we may store fewer items than this if maxSize is hit.}
\DoxyCodeLine{}
\DoxyCodeLine{  max: 500, // <-\/-\/ mandatory, you must give a maximum capacity}
\DoxyCodeLine{}
\DoxyCodeLine{  // if you wish to track item size, you must provide a maxSize}
\DoxyCodeLine{  // note that we still will only keep up to max *actual items*,}
\DoxyCodeLine{  // so size tracking may cause fewer than max items to be stored.}
\DoxyCodeLine{  // At the extreme, a single item of maxSize size will cause everything}
\DoxyCodeLine{  // else in the cache to be dropped when it is added.  Use with caution!}
\DoxyCodeLine{  // Note also that size tracking can negatively impact performance,}
\DoxyCodeLine{  // though for most cases, only minimally.}
\DoxyCodeLine{  maxSize: 5000,}
\DoxyCodeLine{}
\DoxyCodeLine{  // function to calculate size of items.  useful if storing strings or}
\DoxyCodeLine{  // buffers or other items where memory size depends on the object itself.}
\DoxyCodeLine{  // also note that oversized items do NOT immediately get dropped from}
\DoxyCodeLine{  // the cache, though they will cause faster turnover in the storage.}
\DoxyCodeLine{  sizeCalculation: (value, key) => \{}
\DoxyCodeLine{    // return an positive integer which is the size of the item,}
\DoxyCodeLine{    // if a positive integer is not returned, will use 0 as the size.}
\DoxyCodeLine{    return 1}
\DoxyCodeLine{  \},}
\DoxyCodeLine{}
\DoxyCodeLine{  // function to call when the item is removed from the cache}
\DoxyCodeLine{  // Note that using this can negatively impact performance.}
\DoxyCodeLine{  dispose: (value, key) => \{}
\DoxyCodeLine{    freeFromMemoryOrWhatever(value)}
\DoxyCodeLine{  \},}
\DoxyCodeLine{}
\DoxyCodeLine{  // max time to live for items before they are considered stale}
\DoxyCodeLine{  // note that stale items are NOT preemptively removed by default,}
\DoxyCodeLine{  // and MAY live in the cache, contributing to its LRU max, long after}
\DoxyCodeLine{  // they have expired.}
\DoxyCodeLine{  // Also, as this cache is optimized for LRU/MRU operations, some of}
\DoxyCodeLine{  // the staleness/TTL checks will reduce performance, as they will incur}
\DoxyCodeLine{  // overhead by deleting items.}
\DoxyCodeLine{  // Must be a positive integer in ms, defaults to 0, which means "{}no TTL"{}}
\DoxyCodeLine{  ttl: 1000 * 60 * 5,}
\DoxyCodeLine{}
\DoxyCodeLine{  // return stale items from cache.get() before disposing of them}
\DoxyCodeLine{  // boolean, default false}
\DoxyCodeLine{  allowStale: false,}
\DoxyCodeLine{}
\DoxyCodeLine{  // update the age of items on cache.get(), renewing their TTL}
\DoxyCodeLine{  // boolean, default false}
\DoxyCodeLine{  updateAgeOnGet: false,}
\DoxyCodeLine{}
\DoxyCodeLine{  // update the age of items on cache.has(), renewing their TTL}
\DoxyCodeLine{  // boolean, default false}
\DoxyCodeLine{  updateAgeOnHas: false,}
\DoxyCodeLine{}
\DoxyCodeLine{  // update the "{}recently-\/used"{}-\/ness of items on cache.has()}
\DoxyCodeLine{  // boolean, default false}
\DoxyCodeLine{  updateRecencyOnHas: false,}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{const cache = new LRU(options)}
\DoxyCodeLine{}
\DoxyCodeLine{cache.set("{}key"{}, "{}value"{})}
\DoxyCodeLine{cache.get("{}key"{}) // "{}value"{}}
\DoxyCodeLine{}
\DoxyCodeLine{// non-\/string keys ARE fully supported}
\DoxyCodeLine{// but note that it must be THE SAME object, not}
\DoxyCodeLine{// just a JSON-\/equivalent object.}
\DoxyCodeLine{var someObject = \{ a: 1 \}}
\DoxyCodeLine{cache.set(someObject, 'a value')}
\DoxyCodeLine{// Object keys are not toString()-\/ed}
\DoxyCodeLine{cache.set('[object Object]', 'a different value')}
\DoxyCodeLine{assert.equal(cache.get(someObject), 'a value')}
\DoxyCodeLine{// A similar object with same keys/values won't work,}
\DoxyCodeLine{// because it's a different object identity}
\DoxyCodeLine{assert.equal(cache.get(\{ a: 1 \}), undefined)}
\DoxyCodeLine{}
\DoxyCodeLine{cache.clear()    // empty the cache}

\end{DoxyCode}


If you put more stuff in it, then items will fall out.\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9493}{}\doxysection{Options}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9493}

\begin{DoxyItemize}
\item {\ttfamily max} -\/ The maximum number (or size) of items that remain in the cache (assuming no TTL pruning or explicit deletions). Note that fewer items may be stored if size calculation is used, and {\ttfamily max\+Size} is exceeded. This must be a positive finite intger.

This option is required, and must be a positive integer.
\item {\ttfamily max\+Size} -\/ Set to a positive integer to track the sizes of items added to the cache, and automatically evict items in order to stay below this size. Note that this may result in fewer than {\ttfamily max} items being stored.

Optional, must be a positive integer if provided. Required if other size tracking features are used.
\item {\ttfamily size\+Calculation} -\/ Function used to calculate the size of stored items. If you\textquotesingle{}re storing strings or buffers, then you probably want to do something like {\ttfamily n =\texorpdfstring{$>$}{>} n.\+length}. The item is passed as the first argument, and the key is passed as the second argument.

This may be overridden by passing an options object to {\ttfamily cache.\+set()}.

Requires {\ttfamily max\+Size} to be set.

Deprecated alias\+: {\ttfamily length}
\item {\ttfamily dispose} Function that is called on items when they are dropped from the cache, as {\ttfamily this.\+dispose(value, key, reason)}.

This can be handy if you want to close file descriptors or do other cleanup tasks when items are no longer stored in the cache.

{\bfseries{NOTE}}\+: It is called {\itshape before} the item has been fully removed from the cache, so if you want to put it right back in, you need to wait until the next tick. If you try to add it back in during the {\ttfamily dispose()} function call, it will break things in subtle and weird ways.

Unlike several other options, this may {\itshape not} be overridden by passing an option to {\ttfamily set()}, for performance reasons. If disposal functions may vary between cache entries, then the entire list must be scanned on every cache swap, even if no disposal function is in use.

The {\ttfamily reason} will be one of the following strings, corresponding to the reason for the item\textquotesingle{}s deletion\+:
\begin{DoxyItemize}
\item {\ttfamily evict} Item was evicted to make space for a new addition
\item {\ttfamily set} Item was overwritten by a new value
\item {\ttfamily delete} Item was removed by explicit {\ttfamily cache.\+delete(key)} or by calling {\ttfamily cache.\+clear()}, which deletes everything.
\end{DoxyItemize}

Optional, must be a function.
\item {\ttfamily dispose\+After} The same as {\ttfamily dispose}, but called {\itshape after} the entry is completely removed and the cache is once again in a clean state.

It is safe to add an item right back into the cache at this point. However, note that it is {\itshape very} easy to inadvertently create infinite recursion in this way.
\item {\ttfamily no\+Dispose\+On\+Set} Set to {\ttfamily true} to suppress calling the {\ttfamily dispose()} function if the entry key is still accessible within the cache.

This may be overridden by passing an options object to {\ttfamily cache.\+set()}.

Boolean, default {\ttfamily false}. Only relevant if {\ttfamily dispose} or {\ttfamily dispose\+After} options are set.
\item {\ttfamily ttl} -\/ max time to live for items before they are considered stale. Note that stale items are NOT preemptively removed by default, and MAY live in the cache, contributing to its LRU max, long after they have expired.

Also, as this cache is optimized for LRU/\+MRU operations, some of the staleness/\+TTL checks will reduce performance, as they will incur overhead by deleting from Map objects rather than simply throwing old Map objects away.

This is not primarily a TTL cache, and does not make strong TTL guarantees. There is no pre-\/emptive pruning of expired items, but you {\itshape may} set a TTL on the cache, and it will treat expired items as missing when they are fetched, and delete them.

Optional, but must be a positive integer in ms if specified.

This may be overridden by passing an options object to {\ttfamily cache.\+set()}.

Deprecated alias\+: {\ttfamily max\+Age}
\item {\ttfamily no\+Update\+TTL} -\/ Boolean flag to tell the cache to not update the TTL when setting a new value for an existing key (ie, when updating a value rather than inserting a new value). Note that the TTL value is {\itshape always} set (if provided) when adding a new entry into the cache.

This may be passed as an option to {\ttfamily cache.\+set()}.

Boolean, default false.
\item {\ttfamily ttl\+Resolution} -\/ Minimum amount of time in ms in which to check for staleness. Defaults to {\ttfamily 1}, which means that the current time is checked at most once per millisecond.

Set to {\ttfamily 0} to check the current time every time staleness is tested.

Note that setting this to a higher value {\itshape will} improve performance somewhat while using ttl tracking, albeit at the expense of keeping stale items around a bit longer than intended.
\item {\ttfamily ttl\+Autopurge} -\/ Preemptively remove stale items from the cache.

Note that this may {\itshape significantly} degrade performance, especially if the cache is storing a large number of items. It is almost always best to just leave the stale items in the cache, and let them fall out as new items are added.

Note that this means that {\ttfamily allow\+Stale} is a bit pointless, as stale items will be deleted almost as soon as they expire.

Use with caution!

Boolean, default {\ttfamily false}
\item {\ttfamily allow\+Stale} -\/ By default, if you set {\ttfamily ttl}, it\textquotesingle{}ll only delete stale items from the cache when you {\ttfamily get(key)}. That is, it\textquotesingle{}s not preemptively pruning items.

If you set {\ttfamily allow\+Stale\+:true}, it\textquotesingle{}ll return the stale value as well as deleting it. If you don\textquotesingle{}t set this, then it\textquotesingle{}ll return {\ttfamily undefined} when you try to get a stale entry.

Note that when a stale entry is fetched, {\itshape even if it is returned due to {\ttfamily allow\+Stale} being set}, it is removed from the cache immediately. You can immediately put it back in the cache if you wish, thus resetting the TTL.

This may be overridden by passing an options object to {\ttfamily cache.\+get()}. The {\ttfamily cache.\+has()} method will always return {\ttfamily false} for stale items.

Boolean, default false, only relevant if {\ttfamily ttl} is set.

Deprecated alias\+: {\ttfamily stale}
\item {\ttfamily update\+Age\+On\+Get} -\/ When using time-\/expiring entries with {\ttfamily ttl}, setting this to {\ttfamily true} will make each item\textquotesingle{}s age reset to 0 whenever it is retrieved from cache with {\ttfamily get()}, causing it to not expire. (It can still fall out of cache based on recency of use, of course.)

This may be overridden by passing an options object to {\ttfamily cache.\+get()}.

Boolean, default false, only relevant if {\ttfamily ttl} is set.
\end{DoxyItemize}\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9494}{}\doxysection{API}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9494}

\begin{DoxyItemize}
\item {\ttfamily new LRUCache(options)}

Create a new LRUCache. All options are documented above, and are on the cache as public members.
\item {\ttfamily cache.\+max}, {\ttfamily cache.\+max\+Size}, {\ttfamily cache.\+allow\+Stale}, {\ttfamily cache.\+no\+Dispose\+On\+Set}, {\ttfamily cache.\+size\+Calculation}, {\ttfamily cache.\+dispose}, {\ttfamily cache.\+max\+Size}, {\ttfamily cache.\+ttl}, {\ttfamily cache.\+update\+Age\+On\+Get}

All option names are exposed as public members on the cache object.

These are intended for read access only. Changing them during program operation can cause undefined behavior.
\item {\ttfamily cache.\+size}

The total number of items held in the cache at the current moment.
\item {\ttfamily cache.\+calculated\+Size}

The total size of items in cache when using size tracking.
\item {\ttfamily set(key, value, \mbox{[}\{ size, size\+Calculation, ttl, no\+Dispose\+On\+Set \}\mbox{]})}

Add a value to the cache.

Optional options object may contain {\ttfamily ttl} and {\ttfamily size\+Calculation} as described above, which default to the settings on the cache object.

Options object my also include {\ttfamily size}, which will prevent calling the {\ttfamily size\+Calculation} function and just use the specified number if it is a positive integer, and {\ttfamily no\+Dispose\+On\+Set} which will prevent calling a {\ttfamily dispose} function in the case of overwrites.

Will update the recency of the entry.

Returns the cache object.
\item {\ttfamily get(key, \{ update\+Age\+On\+Get, allow\+Stale \} = \{\}) =\texorpdfstring{$>$}{>} value}

Return a value from the cache.

Will update the recency of the cache entry found.

If the key is not found, {\ttfamily get()} will return {\ttfamily undefined}. This can be confusing when setting values specifically to {\ttfamily undefined}, as in {\ttfamily cache.\+set(key, undefined)}. Use {\ttfamily cache.\+has()} to determine whether a key is present in the cache at all.
\item {\ttfamily peek(key, \{ allow\+Stale \} = \{\}) =\texorpdfstring{$>$}{>} value}

Like {\ttfamily get()} but doesn\textquotesingle{}t update recency or delete stale items.

Returns {\ttfamily undefined} if the item is stale, unless {\ttfamily allow\+Stale} is set either on the cache or in the options object.
\item {\ttfamily has(key)}

Check if a key is in the cache, without updating the recency or age.

Will return {\ttfamily false} if the item is stale, even though it is technically in the cache.
\item {\ttfamily delete(key)}

Deletes a key out of the cache.

Returns {\ttfamily true} if the key was deleted, {\ttfamily false} otherwise.
\item {\ttfamily clear()}

Clear the cache entirely, throwing away all values.

Deprecated alias\+: {\ttfamily reset()}
\item {\ttfamily keys()}

Return a generator yielding the keys in the cache.
\item {\ttfamily values()}

Return a generator yielding the values in the cache.
\item {\ttfamily entries()}

Return a generator yielding {\ttfamily \mbox{[}key, value\mbox{]}} pairs.
\item {\ttfamily find(fn, \mbox{[}get\+Options\mbox{]})}

Find a value for which the supplied {\ttfamily fn} method returns a truthy value, similar to {\ttfamily Array.\+find()}.

{\ttfamily fn} is called as {\ttfamily fn(value, key, cache)}.

The optional {\ttfamily get\+Options} are applied to the resulting {\ttfamily get()} of the item found.
\item {\ttfamily dump()}

Return an array of {\ttfamily \mbox{[}key, entry\mbox{]}} objects which can be passed to {\ttfamily cache.\+load()}

Note\+: this returns an actual array, not a generator, so it can be more easily passed around.
\item {\ttfamily load(entries)}

Reset the cache and load in the items in {\ttfamily entries} in the order listed. Note that the shape of the resulting cache may be different if the same options are not used in both caches.
\item {\ttfamily purge\+Stale()}

Delete any stale entries. Returns {\ttfamily true} if anything was removed, {\ttfamily false} otherwise.

Deprecated alias\+: {\ttfamily prune}
\item {\ttfamily for\+Each(fn, \mbox{[}thisp\mbox{]})}

Call the {\ttfamily fn} function with each set of {\ttfamily fn(value, key, cache)} in the LRU cache, from most recent to least recently used.

Does not affect recency of use.

If {\ttfamily thisp} is provided, function will be called in the {\ttfamily this}-\/context of the provided object.
\item {\ttfamily rfor\+Each(fn, \mbox{[}thisp\mbox{]})}

Same as {\ttfamily cache.\+for\+Each(fn, thisp)}, but in order from least recently used to most recently used.
\item {\ttfamily pop()}

Evict the least recently used item, returning its value.

Returns {\ttfamily undefined} if cache is empty.
\end{DoxyItemize}\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9495}{}\doxysubsection{Internal Methods and Properties}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9495}
In order to optimize performance as much as possible, \char`\"{}private\char`\"{} members and methods are exposed on the object as normal properties, rather than being accessed via Symbols, private members, or closure variables.

{\bfseries{Do not use or rely on these.}} They will change or be removed without notice. They will cause undefined behavior if used inappropriately. There is no need or reason to ever call them directly.

This documentation is here so that it is especially clear that this not \char`\"{}undocumented\char`\"{} because someone forgot; it {\itshape is} documented, and the documentation is telling you not to do it.

{\bfseries{Do not report bugs that stem from using these properties.}} They will be ignored.


\begin{DoxyItemize}
\item {\ttfamily initialize\+TTLTracking()} Set up the cache for tracking TTLs
\item {\ttfamily update\+Item\+Age(index)} Called when an item age is updated, by internal ID
\item {\ttfamily set\+Item\+TTL(index)} Called when an item ttl is updated, by internal ID
\item {\ttfamily is\+Stale(index)} Called to check an item\textquotesingle{}s staleness, by internal ID
\item {\ttfamily initialize\+Size\+Tracking()} Set up the cache for tracking item size. Called automatically when a size is specified.
\item {\ttfamily remove\+Item\+Size(index)} Updates the internal size calculation when an item is removed or modified, by internal ID
\item {\ttfamily add\+Item\+Size(index)} Updates the internal size calculation when an item is added or modified, by internal ID
\item {\ttfamily indexes()} An iterator over the non-\/stale internal IDs, from most recently to least recently used.
\item {\ttfamily rindexes()} An iterator over the non-\/stale internal IDs, from least recently to most recently used.
\item {\ttfamily new\+Index()} Create a new internal ID, either reusing a deleted ID, evicting the least recently used ID, or walking to the end of the allotted space.
\item {\ttfamily evict()} Evict the least recently used internal ID, returning its ID. Does not do any bounds checking.
\item {\ttfamily connect(p, n)} Connect the {\ttfamily p} and {\ttfamily n} internal IDs in the linked list.
\item {\ttfamily move\+To\+Tail(index)} Move the specified internal ID to the most recently used position.
\item {\ttfamily key\+Map} Map of keys to internal IDs
\item {\ttfamily key\+List} List of keys by internal ID
\item {\ttfamily val\+List} List of values by internal ID
\item {\ttfamily sizes} List of calculated sizes by internal ID
\item {\ttfamily ttls} List of TTL values by internal ID
\item {\ttfamily starts} List of start time values by internal ID
\item {\ttfamily next} Array of \char`\"{}next\char`\"{} pointers by internal ID
\item {\ttfamily prev} Array of \char`\"{}previous\char`\"{} pointers by internal ID
\item {\ttfamily head} Internal ID of least recently used item
\item {\ttfamily tail} Internal ID of most recently used item
\item {\ttfamily free} Stack of deleted internal IDs
\end{DoxyItemize}\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9496}{}\doxysection{Performance}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9496}
As of January 2022, version 7 of this library is one of the most performant LRU cache implementations in Java\+Script.

Benchmarks can be extremely difficult to get right. In particular, the performance of set/get/delete operations on objects will vary {\itshape wildly} depending on the type of key used. V8 is highly optimized for objects with keys that are short strings, especially integer numeric strings. Thus any benchmark which tests {\itshape solely} using numbers as keys will tend to find that an object-\/based approach performs the best.

Note that coercing {\itshape anything} to strings to use as object keys is unsafe, unless you can be 100\% certain that no other type of value will be used. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const myCache = \{\}}
\DoxyCodeLine{const set = (k, v) => myCache[k] = v}
\DoxyCodeLine{const get = (k) => myCache[k]}
\DoxyCodeLine{}
\DoxyCodeLine{set(\{\}, 'please hang onto this for me')}
\DoxyCodeLine{set('[object Object]', 'oopsie')}

\end{DoxyCode}


Also beware of \char`\"{}\+Just So\char`\"{} stories regarding performance. Garbage collection of large (especially\+: deep) object graphs can be incredibly costly, with several \char`\"{}tipping points\char`\"{} where it increases exponentially. As a result, putting that off until later can make it much worse, and less predictable. If a library performs well, but only in a scenario where the object graph is kept shallow, then that won\textquotesingle{}t help you if you are using large objects as keys.

In general, when attempting to use a library to improve performance (such as a cache like this one), it\textquotesingle{}s best to choose an option that will perform well in the sorts of scenarios where you\textquotesingle{}ll actually use it.

This library is optimized for repeated gets and minimizing eviction time, since that is the expected need of a LRU. Set operations are somewhat slower on average than a few other options, in part because of that optimization. It is assumed that you\textquotesingle{}ll be caching some costly operation, ideally as rarely as possible, so optimizing set over get would be unwise.

If performance matters to you\+:


\begin{DoxyEnumerate}
\item If it\textquotesingle{}s at all possible to use small integer values as keys, and you can guarantee that no other types of values will be used as keys, then do that, and use a cache such as \href{https://npmjs.com/package/lru-fast}{\texttt{ lru-\/fast}}, or \href{https://yomguithereal.github.io/mnemonist/lru-cache}{\texttt{ mnemonist\textquotesingle{}s LRUCache}} which uses an Object as its data store.
\item Failing that, if at all possible, use short non-\/numeric strings (ie, less than 256 characters) as your keys, and use \href{https://yomguithereal.github.io/mnemonist/lru-cache}{\texttt{ mnemonist\textquotesingle{}s LRUCache}}.
\item If the types of your keys will be long strings, strings that look like floats, {\ttfamily null}, objects, or some mix of types, or if you aren\textquotesingle{}t sure, then this library will work well for you.
\item Do not use a {\ttfamily dispose} function, size tracking, or especially ttl behavior, unless absolutely needed. These features are convenient, and necessary in some use cases, and every attempt has been made to make the performance impact minimal, but it isn\textquotesingle{}t nothing.
\end{DoxyEnumerate}\hypertarget{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9497}{}\doxysection{Breaking Changes in Version 7}\label{md__c___users_vaishnavi_jadhav__desktop__developer_code_mean_stack_example_client_node_modules_n2e32aede5ab48713549895d78ad8d6c0_autotoc_md9497}
This library changed to a different algorithm and internal data structure in version 7, yielding significantly better performance, albeit with some subtle changes as a result.

If you were relying on the internals of LRUCache in version 6 or before, it probably will not work in version 7 and above.

For more info, see the change log. 